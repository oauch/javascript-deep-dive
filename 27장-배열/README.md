## 27. 배열

- 자바스크립트에서 배열 = 객체 타입
- 자바스크립트에서 `배열`이라는 타입은 존재하지 않는다.

### 객체

- `키`와 `값`으로 이루어짐
- 프로퍼티 키
- 값의 순서가 없다.
- length 프로퍼티가 없다.

### 배열

- `인덱스`와 `요소`로 이루어짐
- 인덱스
- 값의 순서가 있다.
- length 프로퍼티가 있다.

### 차이점

- 값의 순서 / length 프로퍼티를 갖는다는 큰 차이점
- 이 2개를 가지고 있으면 좋은 점은 순차적으로 값을 접근하기 편리하다.

<br />

## 자바스크립트 배열은 배열이 아니다 👀

- 배열은 `밀집 배열` / `희소 배열`로 구분

### 📍 밀집 배열

- 자료구조에서 일반적으로 언급하는 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조
- 배열의 요소들은 하나의 데이터 타입으로 통일, 서로 연속적으로 인접해 있는 형태 의미
  - 연속적 구조이기 때문에 `인덱스`를 통해 단 한번의 연산으로 요소에 접근 가능
  - 정렬되지 않은 배열이면서 특정 요소를 검색할 경우, 배열의 모든 요소를 처음부터 원하는 요소까지 순회해야하므로 `시간 복잡도`를 가지게 된다.
  - 배열에 요소를 삽입 / 삭제 하는 경우도 연속적인 구조를 유지시키기 위해서 요소를 작업마다 이동시켜야 하는 단점도 존재

### 📍 희소 배열

- 배열의 요소들의 각각의 메모리 공간이 동일한 크기를 갖지 않아도 되고, 연속적으로 이어져 있지 않아도 된다.
- 이를 희소 배열이라고 하며, 자바스크립트 배열 = `희소 배열`
- 자바스크립트 배열은 일반적인 배열의 동작을 흉내 낸 특수한 객체
- 배열의 요소는 사실 프로퍼티 값
  - 자바스크립트에서 사용할 수 있는 모든 값 = `객체의 프로퍼티 값`이 될 수 있으므로 어떤 타입의 값도 배열의 요소가 될 수 있다.

## length 프로퍼티 / 희소 배열

- length 프로퍼티는 배열의 요소 개수를 나타낸다.
- length의 값은 최대 2^32 - 1 개의 요소를 가질 수 있다.
- 기본적으로 배열의 길이를 바탕으로 결정되지만 `임의의 숫자 값을 명시적으로 할당 가능`
  - 현재 프로퍼티의 length 프로퍼티 값보다 `작은 숫자 값`을 할당할 경우 = 배열의 길이가 줄어듬
  - 현재 프로퍼티의 length 프로퍼티 값보다 `큰 숫자의 값`을 할당할 경우 = length 프로퍼티 값은 변경 되지만, 실제 배열의 길이는 변함 없다.

<br />

- 자바스크립트 엔진은 희소 배열을 문법적으로 허용
- 하지만 희소 배열은 의도적으로 생성하는 일은 많지 않아서, 가능한 사용하지 않는게 좋다.
- 배열에는 같은 타입의 요소를 연속적으로 위치 시키는 것이 최선

## 배열 생성

---

### 1. 배열 리터럴

- 배열을 생성하는 가장 간단한 방식
- 배열 리터럴에 요소를 생략하면 희소 배열 생성

```javascript
// 배열의 요소를 생략하면 "희소 배열"생성
const arr = [1, , 3];

console.log(arr.length); // 3
console.log(arr); // [ 1, <1 empty item>, 3 ]
console.log(arr[1]); // undefined
```

### 2. Array 생성자 함수

- 인수의 개수에 따라 다르게 동작
- 전달된 인수가 없을 경우 -> 빈 배열 생성
- 전달된 인수가 1개이고 숫자일 경우 -> length 프로퍼티 값이 인수인 배열 생성
- 전달된 인수가 2개이상이거나 숫자가 아닌 경우 -> 인수를 요소로 갖는 배열 생성

```javascript
// 인수가 1개이며 정수인 경우 -> 희소 배열 생성
const arr = new Array(10);

console.log(arr); // [ <10 empty items> ]
console.log(arr.length); // 10
console.log(Object.getOwnPropertyDescriptors(arr)); // { length: { value: 10, writable: true, enumerable: false, configurable: false } }

new Array(4294967295);
new Array(4294967296); // RangeError: Invalid array length
new Array(-1); // RangeError: Invalid array length

// 인수가 없는 경우 -> 빈 배열 생성
new Array(); // []

// 인수가 2개 이상이거나 숫자가 아닌 경우 -> 인수를 요소로 갖는 배열을 생성
new Array(1, 2, 3); // [1,2,3]
new Array({}); // [{}]
```

### 3. Array.of 메서드

- ES6 도입
- 전달된 인수를 갖는 배열 생성
- 인수가 1개이고 숫자여도 인수를 요소로 갖는 배열 생성

```javascript
const arr1 = Array.of(1);
const arr2 = Array.of(1, 2, 3);
const arr3 = Array.of("string");

console.log(arr1); // [ 1 ]
console.log(arr2); // [ 1, 2, 3 ]
console.log(arr3); // [ 'string' ]
```

### 4. Array.from 메서드

- ES6 도입
- 유사 배열 객체 (array-like object) / 이터러블 객체 (iterable object)를 인수로 전달 받아 배열로 변환 후 반환
- 두번째 인수로 함께 전달할 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다.

```javascript
// 유사 배열 객체를 배열로 변환
const arr1 = Array.from({ length: 2, 0: "a", 1: "b" });

// 이터러블 객체를 배열로 변환
// 문자열은 "이터러블 객체"이기도 하다.
const arr2 = Array.from("Hi");

console.log(arr1); // [ 'a', 'b' ]
console.log(arr2); // [ 'H', 'i' ]
```

<br />

## 배열 참조

- 배열을 참조할 때 대괄호를 사용, 대괄호 안에는 인덱스 ex) `arr[index]`
- 정수로 평가되는 표현식 = 인덱스로 사용 가능
- 존재하지 않는 요소에 접근하면 `undefined` 반환
  - 배열은 `객체이기 때문에` 객체에서 존재하지 않는 프로퍼티에 접근하면 undefined를 반환하는 것과 같다.

```javascript
// 희소 배열
const arr = [1, , 3];

// arr 배열의 1번째 인덱스에는 요소가 존재하지 않는다.
// 하지만, length 프로퍼티는 empty 요소도 포함해서 길이를 측정한다.
// 단, 실질적인 배열 프로퍼티의 메모리 공간에는 빈 요소의 영역은 할당되지 않는다.
console.log(Object.getOwnPropertyDescriptors(arr));
// {
//   '0': { value: 1, writable: true, enumerable: true, configurable: true },
//   '2': { value: 3, writable: true, enumerable: true, configurable: true },
//   length: { value: 3, writable: true, enumerable: false, configurable: false }
// }

// 존재하지 않는 요소를 참조하면 undefined
console.log(arr[1]); // undefined
console.log(arr[3]); // undefined
```

<br />

## 배열 요소의 추가 / 갱신 / 삭제

---

### 추가 / 갱신

- `배열 = 객체`이므로 객체의 프로퍼티를 동적으로 추가할 수 있는 것처럼 `배열에도 동적 추가 가능`
- 만약, 현재 배열의 length 프로퍼티 값보다 큰 인덱스로 새로운 요소를 추가하면 희소 배열이 된다.
  - 명시적으로 값이 할당되지 않은 희소 배열의 요소들은 생성 ❌
  - length 프로퍼티 값은 변하나, 실질적으로 배열안에 요소의 개수 변하지 않는다.
- 0이상 정수로 인덱싱에 사용해야 한다.
  - 만약, 정수 이외의 값을 인덱싱에 사용하면 요소가 생성되는 것이 아니라 프로퍼티 생성
  - 프로퍼티는 length 프로퍼티 값에 영향을 주지 않는다.

### 삭제

- 배열도 객체이므로 배열의 특정 요소를 삭제하기 위해 delete 연산자를 사용할 수 있다.
- delete 연산자를 통해 배열의 요소를 삭제하는 것은 객체의 프로퍼티를 삭제하는 개념과 같다.
  - 요소의 값이 삭제되면 희소 배열이 된다.
  - 이 때, length 프로퍼티에는 영향을 주지 않는다.
- 따라서, 희소배열을 만들지 않으면서 배열을 삭제하고 싶은 경우 splice()메소드를 사용한다.
